# spring-security

When ever we install spring-boot-security dependency and try to access the controller
automatically the user-name and password page opens
Default username: user
passwor: It is generated at the time of starting of the application.

If we dont want default user name and password then we can add the following properties in applicaiton.properties file
spring.security.user.name=manish
spring.security.user.password=default


# The very first filter which plays a vital role is 
## AuthorizationFilter: 
If URL is public it wont do anything but if URL is secured then It will redirect to another URL

The AuthorizationFilter checks the url is secured or not with the help of AuthorizationManager 
AuthorizationDecision decision = this.authorizationManager.check(this::getAuthentication, request);

If the URL is secured then the next filter will be executed that is 
## DefaultLoginPageGeneratingFilter 

In the above case we saw that before accessing the secured URL a login page populated in our browser. This login page is generated by DefaultLoginPageGeneratingFilter
generateLoginPageHtml (function name)

After that the next Filter which will execute is 
## UsernamePasswordAuthenticationFilter : 
In this filter there is method called attemptAuthentication and the responsibility of this filter is extract the username and password from the http servlate request it
receives, and with the help of this username and password an Object is created of type ## UsernamePasswordAuthenticationToken (which is implementation of Authentication interface)

After this AuthenticationManager filter gets executed and inside it authenticate method gets executed.
It will iterate all the authentication provider and checks if credential is valid or not.
for (AuthenticationProvider provider : getProviders()) {
			if (!provider.supports(toTest)) {
				continue;
			}
			if (logger.isTraceEnabled()) {
				logger.trace(LogMessage.format("Authenticating request with %s (%d/%d)",
						provider.getClass().getSimpleName(), ++currentPosition, size));
			}
			try {
				result = provider.authenticate(authentication);
				if (result != null) {
					copyDetails(authentication, result);
					break;
				}
			}
			catch (AccountStatusException | InternalAuthenticationServiceException ex) {
				prepareException(ex, authentication);
				// SEC-546: Avoid polling additional providers if auth failure is due to
				// invalid account status
				throw ex;
			}
			catch (AuthenticationException ex) {
				lastException = ex;
			}
		}


After that DaoAuthenticationProvider filter is executed under which a function authenticate(Authentication authentication) gets executed
Note: authenticate(Authentication authentication) is available in AbstractUserDetailsAuthenticationProvider and AbstractUserDetailsAuthenticationProvider is being extended in DeaoAuthenticationProvider class


If we login for the first time the browser sends jssionid inside a cookies, and spring security creates the session id and add it in the cookies also spring stores the session id in the security context.
When the user tries to second time then the user sends the same sessionid which spring had generated and spring check the sessionid in the security context and provide the access to the secured URL
